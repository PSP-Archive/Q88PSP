/************************************************************************/
/*									*/
/* インジケータの表示 (FDD表示、ほかメッセージ表示)			*/
/*									*/
/************************************************************************/

#include <stdio.h>
#include <string.h>

#include "quasi88.h"
#include "initval.h"
#include "indicator.h"

#include "pc88main.h"		/* boot_basic	*/
#include "graph.h"
#include "memory.h"		/* font_rom	*/
#include "screen.h"

#include "emu.h"		/* emu_mode	*/
#include "drive.h"
#include "snddrv.h"		/* xmame_get_sound_volume()	*/
#include "wait.h"		/* wait_freq_hz			*/
#include "intr.h"		/* no_wait			*/
#include "menu.h"		/* menu_lang			*/


/*--------------------------------------------------------------*/
/* タイトルロゴでの表示メッセージは messange.c にあります	*/
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/

Uint	indicator_flag = 0;			/* 各種状態の表示	*/
						/* bit毎に意味をもつ	*/

int	bootup_logo = TRUE;			/* タイトルロゴ表示・非表示 */

static	int	change_indicator = FALSE;	/* 表示する瞬間、真	*/



/*----------------------------------------------------------------------*/
/* ビットマップ作業バッファ						*/
/*----------------------------------------------------------------------*/
static	Uchar	bitmap_buffer[ 320 * 80 ];

static	struct{			/* ビットマップを表示した座標 */
  int	use;
  int	x0, y0, x1, y1;
} bitinfo[2];






/*----------------------------------------------------------------------*/
/* メッセージなどを消去する。						*/
/*	実際の消去は、VRAMやTEXTが screen_buffer を上書きすることで行う	*/
/*	すなわち、ここでは、screen_update を制御する。			*/
/*----------------------------------------------------------------------*/
void	clear_indicator( void )
{
#define	MAX(a,b)	(((a)>(b))?(a):(b))
#define	MIN(a,b)	(((a)<(b))?(a):(b))
  int	id, x0, x1, y0, y1, i, j;
  int	job[2];



  job[0] = job[1] = FALSE;

  if( bitinfo[ 0 ].use    &&				/* 現在FDD表示中で、*/
      (indicator_flag & INDICATE_FDD)==FALSE  ){	/* 状態が「消去」   */
    job[0] = TRUE;
  }

  if( bitinfo[ 1 ].use    &&				/* 現在MES表示中で、*/
      ( change_indicator ||				/* 別MES表示、または*/ 
	(indicator_flag & INDICATE_MES)==FALSE )){	/* 状態が「消去」   */
    job[1] = TRUE;
  }



  for( id=0; id<2; id ++ ){

    if( job[id] ){				/* 消去フラグONなら	*/
      x0 = bitinfo[id].x0;
      x1 = bitinfo[id].x1;
      y0 = bitinfo[id].y0;
      y1 = bitinfo[id].y1;

      {						/* 消去 (黒で埋める)	*/
	int	i, j;
	Ulong	color = color_pixel[8];
	bit8	*p = (bit8  *)&screen_buf[0] + WIDTH*y0 + x0;
	bit16	*q = (bit16 *)&screen_buf[0] + WIDTH*y0 + x0;
	bit32	*r = (bit32 *)&screen_buf[0] + WIDTH*y0 + x0;

	for( j=0; j<y1-y0; j++ ){
	  for( i=0; i<x1-x0; i++ ){
	    if     ( DEPTH<= 8 ) p[ WIDTH*j + i ] = color;
	    else if( DEPTH<=16 ) q[ WIDTH*j + i ] = color;
	    else                 r[ WIDTH*j + i ] = color;
	  }
	}
      }

      /* インジケータ表示エリアが88VRAMの表示エリアと重なっているかチェック */

      if( (( SCREEN_DX <= x0  &&  x0 < SCREEN_DX + SCREEN_W ) ||
	   ( SCREEN_DX <= x1  &&  x1 < SCREEN_DX + SCREEN_W ) )  &&
	  (( SCREEN_DY <= y0  &&  y0 < SCREEN_DY + SCREEN_H ) ||
	   ( SCREEN_DY <= y1  &&  y1 < SCREEN_DY + SCREEN_H ) )  ){

	int line200 = ( grph_ctrl&GRPH_CTRL_COLOR || grph_ctrl&GRPH_CTRL_200 );

		/* updateする範囲 (dot単位) */

	x0 = MAX( x0, SCREEN_DX )          - SCREEN_DX;
	x1 = MIN( x1, SCREEN_DX+SCREEN_W ) - SCREEN_DX;
	y0 = MAX( y0, SCREEN_DY )          - SCREEN_DY;
	y1 = MIN( y1, SCREEN_DY+SCREEN_H ) - SCREEN_DY;


		/* updateする範囲 (88vram byte単位) */

	if( screen_size == SCREEN_SIZE_FULL ){		/* 標準 */
	    x0 = ( x0+7 ) / 8;
	    x1 = ( x1+7 ) / 8;
	    if( line200 ){ 
		y0 = ( y0+1 ) / 2;   
		y1 = ( y1+1 ) / 2; 
	    }
	}else if( screen_size == SCREEN_SIZE_HALF ){	/* 半分 */
	    x0 = ( x0+3 ) / 4;
	    x1 = ( x1+3 ) / 4;
	    if( ! line200 ){
		y0 *= 2;   
		y1 *= 2; 
	    }
	}else{						/* 倍   */
	    x0 = ( x0+15 ) / 16;
	    x1 = ( x1+15 ) / 16;
	    if( line200 ){ 
		y0 /= 4; 
		y1 /= 4;
	    }else{
		y0 /= 2;
		y1 /= 2;
	    }
	}

		/* 範囲を1で埋める */

	for( j=y0; j<y1; j++ ){
	  for( i=x0; i<x1; i++ ){
	    set_screen_update( j*80 + i );
	  }
	}
      }

      bitinfo[id].use = FALSE;
      do_update = TRUE;
    }
  }
#undef	MAX
#undef	MIN
}


/************************************************************************/



/*----------------------------------------------------------------------*/
/* 画面にビットマップを表示する						*/
/*	表示位置(x,y)、サイズ(sx,sy)、イメージ、ID を指定		*/
/*	表示位置は、x, y 座標をドット単位で指定。			*/
/*		x は、8の倍数で、  0 ≦ x ＜ WIDTH			*/
/*		y は、2の倍数で、  0 ≦ y ＜ HEIGHT			*/
/*		座標が -1 の場合は、センタリングする。			*/
/*		画面からはみ出た場合は、勝手に画面中央に寄せられる	*/
/*	サイズ sx は 8の倍数、sy は 2の倍数				*/
/*	イメージは、bit が 1 で黒、0 で白とする。			*/
/*	ID は、0 か 1 (表示情報を保存するため。差分表示用)		*/
/*----------------------------------------------------------------------*/
static void indicate_bitmap( int x, int y, int sx, int sy, 
			     Uchar *bitmap, int id )
{
  int	i, j, k;
  Ulong color;
  Uchar	style, mask;
  bit8	*p;
  bit16 *q;
  bit32 *r;

#if 0
  if( x < 0 )            x = ( WIDTH - sx ) / 2;	/* x座標 補正 */
  if( x + sx >= WIDTH )  x = WIDTH - sx;
  if( x < 0 || x >= WIDTH ) return;
  x &= ~7;  sx &= ~7;  

  if( y < 0 )            y = ( HEIGHT - sy ) / 2;	/* y座標 補正 */
  if( y + sy >= HEIGHT ) y = HEIGHT - sy;
  if( y < 0 || y >= HEIGHT ) return;
  y &= ~1;  sy &= ~1;
#else
							/* x座標 補正 */
  if( x < 0 )				  x = ( WIDTH - sx ) / 2;
  if( x < VIEWPORT_DX )                   x = VIEWPORT_DX;
  if( x + sx > VIEWPORT_DX + VIEWPORT_W ) x = VIEWPORT_DX + VIEWPORT_W - sx;
  if( x < VIEWPORT_DX || x >= VIEWPORT_DX + VIEWPORT_W ) return;
  x &= ~7;  sx &= ~7;  
							/* y座標 補正 */
  if( y < 0 )                             y = ( HEIGHT - sy ) / 2;
  if( y < VIEWPORT_DY )                   y = VIEWPORT_DY;
  if( y + sy >= VIEWPORT_DY + VIEWPORT_H ) y = VIEWPORT_DY + VIEWPORT_H - sy;
  if( y < VIEWPORT_DY || y >= VIEWPORT_DY + VIEWPORT_H ) return;
  y &= ~1;  sy &= ~1;

#endif



  p = (bit8  *)&screen_buf[0] + WIDTH*y + x;		/* 表示位置ポインタ */
  q = (bit16 *)&screen_buf[0] + WIDTH*y + x;
  r = (bit32 *)&screen_buf[0] + WIDTH*y + x;

  for( j=0; j<sy; j++ ){
    for( i=0; i<sx; i+=8 ){
      style = *bitmap++;
      for( k=0, mask=0x80;  k<8;  k++, mask>>=1 ){
	if( style & mask ) color = color_pixel[8];
	else               color = color_pixel[15];
	if     ( DEPTH<= 8 ) p[ WIDTH*j + i+k ] = color;
	else if( DEPTH<=16 ) q[ WIDTH*j + i+k ] = color;
	else                 r[ WIDTH*j + i+k ] = color;
      }
    }
  }

  bitinfo[ id ].use = TRUE;
  bitinfo[ id ].x0  = x;
  bitinfo[ id ].x1  = x + sx;
  bitinfo[ id ].y0  = y;
  bitinfo[ id ].y1  = y + sy;
}



/*----------------------------------------------------------------------*/
/* ビットマップに文字列をセットする					*/
/*	セット先のビットマップへのポインタ、および、サイズを指定。	*/
/*	セットする文字列のモード( -1:ANK  0:ANK(8x16)  1:EUC(8or16x16) )*/
/*	セットする文字列 を指定する。					*/
/*----------------------------------------------------------------------*/
static	void	indicate_puts( Uchar *buf, int sx, int mode, 
			       const Uchar *str )
{
  int	i, c, c1;
  int	addr, type;	/* type ==0 … 8x8 / ==1 … 8x16 / ==2 … 16x16	*/
  Uchar	*font_ptr;

  while( (c = *str++) ){

    if( mode <= 0 ){				/* ANK */

      font_ptr = &font_rom[ c << 3 ];
      if( mode < 0 ) type = 0;
      else           type = 1;

    }else{

      if( c < 0x80 ){				/* ASCII */

	font_ptr = &font_rom[ c << 3 ];
	type = 1;

      }else if( c == 0x8e ){			/* 半角カナなど */

	c = *str++;
	if( c < 0x80 ) break;
	font_ptr = &font_rom[ c << 3 ];
	type = 1;

      }else{					/* 漢字 */

	c1 = *str++;
	if( c1 < 0x80 ) break;
	addr = (((Uint)c & 0x7f ) << 8 ) | ( (Uint)c1 & 0x7f );
	if( addr < 0x3000 ){
	  addr = ((addr&0x0060)<<7) | ((addr&0x0700)<<1) | ((addr&0x001f)<<4);
	}else{
	  addr = ((addr&0x0060)<<9) | ((addr&0x1f00)<<1) | ((addr&0x001f)<<4);
	}
	font_ptr = &kanji_rom[0][ addr ][0];
	type = 2;

      }
    }

    if( type==0 ){			/* 8x8 */
      for( i=0; i<8; i++ )
	*( buf + i*sx ) = *font_ptr++;
      buf ++;
    }else if( type==1 ){		/* 8x16 */
      for( i=0; i<16; i+=2 )
	*( buf +  i   *sx ) = 
	*( buf + (i+1)*sx ) = *font_ptr++;
      buf ++;
    }else{				/* 16x16*/
      for( i=0; i<16; i++ ){
	*( buf + i*sx    ) = *font_ptr++;
	*( buf + i*sx +1 ) = *font_ptr++;
      }
      buf += 2;
    }
  }
}



/*----------------------------------------------------------------------*/
/* ビットマップをコピーする						*/
/*	コピー先、コピー先のサイズ、コピー元、コピー元のサイズを指定	*/
/*	コピー先のサイズは、x方向サイズのみでOK				*/
/*----------------------------------------------------------------------*/
static void bitmap_copy( Uchar *dst, int d_sx, Uchar *src, int s_sx, int s_sy )
{
  int i, j;

  s_sx /= 8;
  d_sx /= 8;

  for( j=0; j<s_sy; j++ ){
    for( i=0; i<s_sx; i++ ){
      dst[ j*d_sx  + i ] = src[ j*s_sx + i ];
    }
  }
}





/*----------------------------------------------------------------------*/
/* 画面中央に8x8のANK文字列を1行(80文字以内)表示する			*/
/*	文字のスケーリング (scale_x, scale_y) 、文字列を指定		*/
/*	スケーリングの組み合わせは (1,1)、(1,2)、(2,2) のみ		*/
/*	文字列の上下 8dot 分の空白をあわせて表示する。			*/
/*----------------------------------------------------------------------*/

static	void	indicate_font( char *str )
{
  int sx, sy, size;
  Uchar *buf_ptr;

  if( screen_size==SCREEN_SIZE_HALF ) size = -1;
  else                                size = 0;

  sx = strlen( str );
  sy = ((size==0) ? 16 : 8) + 16;		/* 16 は上下の空白部(8dot*2) */
  memset( bitmap_buffer, 0, sx*sy );

  buf_ptr = &bitmap_buffer[ sx * 8 ];		/*  8 は上部の空白部(8dot) */
  indicate_puts( buf_ptr, sx, size, (Uchar*)str );


	/* 表示する。ANKのメッセージは、ID==1 */

  indicate_bitmap( -1, -1, sx*8, sy, bitmap_buffer, 1 );
  return;
}




/*----------------------------------------------------------------------*/
/* 画面中央にタイトルロゴを表示する					*/
/*									*/
/*									*/
/*----------------------------------------------------------------------*/
static Uchar bitmap192x48_logo[]={
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x07,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x1f,0xfc,0x00,0x7f,0xc0,0x0f,0xf8,0x00,0x7f,0xc0,0x00,0x00,0x0f,0xf1,0xff,0x00,0x01,0xf8,0x00,0x00,0x07,0xe0,0x00,
0x00,0x7f,0xff,0x00,0x7f,0xc0,0x0f,0xf8,0x01,0xff,0xf0,0x00,0x00,0x7f,0xf1,0xff,0x00,0x07,0xfe,0x00,0x00,0x1f,0xf8,0x00,
0x00,0xff,0xff,0x80,0x7f,0xc0,0x0f,0xf8,0x07,0xff,0xfc,0x00,0x01,0xff,0xf1,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0xff,0xff,0xc0,0x7f,0xc0,0x0f,0xf8,0x0f,0xff,0xfe,0x00,0x03,0xff,0xf1,0xff,0x00,0x7f,0xff,0xe0,0x01,0xff,0xff,0x80,
0x03,0xff,0xff,0xe0,0x7f,0xc0,0x0f,0xf8,0x1f,0xff,0xff,0x00,0x07,0xff,0xf1,0xff,0x00,0xff,0xff,0xf0,0x03,0xff,0xff,0xc0,
0x07,0xff,0xff,0xf0,0x7f,0xc0,0x0f,0xf8,0x3f,0xff,0xff,0x80,0x0f,0xff,0xf1,0xff,0x00,0xff,0xff,0xf0,0x03,0xff,0xff,0xc0,
0x07,0xff,0xff,0xf0,0x7f,0xc0,0x0f,0xf8,0x3f,0xff,0xff,0x80,0x0f,0xff,0xf1,0xff,0x01,0xff,0xff,0xf8,0x07,0xff,0xff,0xe0,
0x0f,0xff,0xff,0xf8,0x7f,0xc0,0x0f,0xf8,0x7f,0xff,0xff,0xc0,0x1f,0xff,0xf1,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x0f,0xff,0xff,0xf8,0x7f,0xc0,0x0f,0xf8,0x7f,0xff,0xff,0xc0,0x1f,0xff,0xf1,0xff,0x03,0xff,0xff,0xfc,0x0f,0xff,0xff,0xf0,
0x0f,0xfe,0x3f,0xf8,0x7f,0xc0,0x0f,0xf8,0x7f,0xf1,0xff,0xc0,0x1f,0xfe,0x01,0xff,0x03,0xff,0x9f,0xfc,0x0f,0xfe,0x7f,0xf0,
0x1f,0xfc,0x1f,0xfc,0x7f,0xc0,0x0f,0xf8,0xff,0xe0,0xff,0xe0,0x3f,0xf8,0x01,0xff,0x07,0xfe,0x07,0xfe,0x1f,0xf8,0x1f,0xf8,
0x1f,0xfc,0x1f,0xfc,0x7f,0xc0,0x0f,0xf8,0xff,0xc0,0x7f,0xe0,0x3f,0xf0,0x01,0xff,0x07,0xfc,0x03,0xfe,0x1f,0xf0,0x0f,0xf8,
0x1f,0xf8,0x0f,0xfc,0x7f,0xc0,0x0f,0xf8,0xff,0xc0,0x7f,0xe0,0x3f,0xe0,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3f,0xf0,0x07,0xfe,0x7f,0xc0,0x0f,0xf9,0xff,0x80,0x3f,0xf0,0x3f,0xe0,0x01,0xff,0x07,0xfc,0x03,0xfe,0x1f,0xf0,0x0f,0xf8,
0x3f,0xf0,0x07,0xfe,0x7f,0xc0,0x0f,0xf9,0xff,0x80,0x3f,0xf0,0x3f,0xe0,0x01,0xff,0x07,0xfc,0x03,0xfe,0x1f,0xf0,0x0f,0xf8,
0x3f,0xf0,0x07,0xfe,0x7f,0xc0,0x0f,0xf9,0xff,0x80,0x3f,0xf0,0x3f,0xe0,0x01,0xff,0x07,0xfe,0x07,0xfe,0x1f,0xf8,0x1f,0xf8,
0x3f,0xe0,0x03,0xfe,0x7f,0xc0,0x0f,0xf9,0xff,0x00,0x1f,0xf0,0x3f,0xe0,0x01,0xff,0x03,0xff,0x9f,0xfc,0x0f,0xfe,0x7f,0xf0,
0x3f,0xe0,0x03,0xfe,0x7f,0xc0,0x0f,0xf9,0xff,0x00,0x1f,0xf0,0x3f,0xf0,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3f,0xe0,0x03,0xfe,0x7f,0xc0,0x0f,0xf9,0xff,0x00,0x1f,0xf0,0x3f,0xf0,0x01,0xff,0x03,0xff,0xff,0xfc,0x0f,0xff,0xff,0xf0,
0x3f,0xe0,0x03,0xfe,0x7f,0xc0,0x0f,0xf9,0xff,0x00,0x1f,0xf0,0x1f,0xf8,0x01,0xff,0x01,0xff,0xff,0xf8,0x07,0xff,0xff,0xe0,
0x3f,0xe0,0x03,0xfe,0x7f,0xc0,0x0f,0xf9,0xff,0x00,0x1f,0xf0,0x1f,0xfc,0x01,0xff,0x01,0xff,0xff,0xf8,0x07,0xff,0xff,0xe0,
0x3f,0xe0,0x03,0xfe,0x7f,0xc0,0x0f,0xf9,0xff,0x00,0x1f,0xf0,0x0f,0xfe,0x01,0xff,0x01,0xff,0xff,0xf8,0x07,0xff,0xff,0xe0,
0x3f,0xe0,0x03,0xfe,0x7f,0xc0,0x0f,0xf9,0xff,0x00,0x1f,0xf0,0x07,0xff,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3f,0xe0,0x03,0xfe,0x7f,0xc0,0x0f,0xf9,0xff,0x3f,0xff,0xf0,0x07,0xff,0x81,0xff,0x03,0xff,0xff,0xfc,0x0f,0xff,0xff,0xf0,
0x3f,0xe0,0x03,0xfe,0x7f,0xc0,0x0f,0xf9,0xff,0x3f,0xff,0xf0,0x03,0xff,0xc1,0xff,0x07,0xff,0xff,0xfe,0x1f,0xff,0xff,0xf8,
0x3f,0xe0,0x13,0xfe,0x7f,0xc0,0x0f,0xf9,0xff,0x3f,0xff,0xf0,0x01,0xff,0xc1,0xff,0x07,0xff,0x9f,0xfe,0x1f,0xfe,0x7f,0xf8,
0x3f,0xe0,0x3b,0xfe,0x7f,0xc0,0x0f,0xf9,0xff,0x3f,0xff,0xf0,0x00,0xff,0xe1,0xff,0x0f,0xfe,0x07,0xff,0x3f,0xf8,0x1f,0xfc,
0x3f,0xe0,0x7f,0xfe,0x7f,0xc0,0x0f,0xf9,0xff,0x3f,0xff,0xf0,0x00,0x7f,0xe1,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3f,0xf0,0xff,0xfe,0x7f,0xc0,0x0f,0xf9,0xff,0x3f,0xff,0xf0,0x00,0x3f,0xf1,0xff,0x0f,0xfc,0x03,0xff,0x3f,0xf0,0x0f,0xfc,
0x3f,0xf1,0xff,0xfe,0x7f,0xc0,0x0f,0xf9,0xff,0x3f,0xff,0xf0,0x00,0x3f,0xf1,0xff,0x0f,0xf8,0x01,0xff,0x3f,0xe0,0x07,0xfc,
0x3f,0xf1,0xff,0xfe,0x7f,0xc0,0x0f,0xf9,0xff,0x3f,0xff,0xf0,0x00,0x1f,0xf1,0xff,0x0f,0xf8,0x01,0xff,0x3f,0xe0,0x07,0xfc,
0x1f,0xf8,0xff,0xfc,0x7f,0xc0,0x0f,0xf9,0xff,0x3f,0xff,0xf0,0x00,0x1f,0xf1,0xff,0x0f,0xf8,0x01,0xff,0x3f,0xe0,0x07,0xfc,
0x1f,0xfc,0x7f,0xfc,0x7f,0xe0,0x1f,0xf9,0xff,0x00,0x1f,0xf0,0x00,0x3f,0xf1,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x1f,0xfc,0x7f,0xfc,0x7f,0xf8,0x7f,0xf9,0xff,0x00,0x1f,0xf0,0x00,0x7f,0xf1,0xff,0x0f,0xfc,0x03,0xff,0x3f,0xf0,0x0f,0xfc,
0x0f,0xfe,0x3f,0xf8,0x7f,0xff,0xff,0xf9,0xff,0x00,0x1f,0xf0,0x01,0xff,0xf1,0xff,0x0f,0xfe,0x07,0xff,0x3f,0xf8,0x1f,0xfc,
0x0f,0xff,0xff,0xf8,0x7f,0xff,0xff,0xf9,0xff,0x00,0x1f,0xf0,0x0f,0xff,0xf1,0xff,0x0f,0xff,0x9f,0xff,0x3f,0xfe,0x7f,0xfc,
0x0f,0xff,0xff,0xfc,0x3f,0xff,0xff,0xf1,0xff,0x00,0x1f,0xf3,0xff,0xff,0xe1,0xff,0x07,0xff,0xff,0xfe,0x1f,0xff,0xff,0xf8,
0x07,0xff,0xff,0xfe,0x3f,0xff,0xff,0xf1,0xff,0x00,0x1f,0xf3,0xff,0xff,0xe1,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x07,0xff,0xff,0xff,0x1f,0xff,0xff,0xe1,0xff,0x00,0x1f,0xf3,0xff,0xff,0xc1,0xff,0x03,0xff,0xff,0xfc,0x0f,0xff,0xff,0xf0,
0x03,0xff,0xff,0xff,0x1f,0xff,0xff,0xe1,0xff,0x00,0x1f,0xf3,0xff,0xff,0x81,0xff,0x01,0xff,0xff,0xf8,0x07,0xff,0xff,0xe0,
0x01,0xff,0xff,0xfe,0x0f,0xff,0xff,0xc1,0xff,0x00,0x1f,0xf3,0xff,0xff,0x01,0xff,0x00,0xff,0xff,0xf0,0x03,0xff,0xff,0xc0,
0x00,0xff,0xff,0xfc,0x07,0xff,0xff,0x81,0xff,0x00,0x1f,0xf3,0xff,0xfe,0x01,0xff,0x00,0x7f,0xff,0xe0,0x01,0xff,0xff,0x80,
0x00,0x7f,0xff,0x78,0x01,0xff,0xfe,0x01,0xff,0x00,0x1f,0xf3,0xff,0xf8,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x1f,0xfc,0x30,0x00,0xff,0xfc,0x01,0xff,0x00,0x1f,0xf3,0xff,0xc0,0x01,0xff,0x00,0x0f,0xff,0x00,0x00,0x3f,0xfc,0x00,
0x00,0x07,0xf0,0x00,0x00,0x1f,0xe0,0x01,0xff,0x00,0x1f,0xf3,0xfe,0x00,0x01,0xff,0x00,0x03,0xfc,0x00,0x00,0x0f,0xf0,0x00,
};

/*----------------------------------------------------------------------*/
/* 配置									*/
/*									*/
/*		+-------------------------+				*/
/*	4	|     192		  |				*/
/*		|  +-------+	  80	  |				*/
/*		|  |       |   +------+   |				*/
/*	48	|  | TITLE |   |Ver.  |	  |16				*/
/*		|  +-------+   +------+	  |				*/
/*	8	|16	    16		16|				*/
/*		| +---------------------+ |				*/
/*	16	| |GUIDE	        | |				*/
/*		| +---------------------+ |				*/
/*	4	|			  |				*/
/*		+-------------------------+				*/
/*		 8	    304		 8				*/
/*----------------------------------------------------------------------*/
static	void	indicate_logo( void )
{
  int i;
  Uchar *buf_ptr;
  const Uchar *mes;

  memset( bitmap_buffer, 0, sizeof(bitmap_buffer) );


	/* タイトル */

  buf_ptr = &bitmap_buffer[ (320*4 + 16) / 8 ];
  bitmap_copy( buf_ptr, 320, bitmap192x48_logo, 192, 48 );


	/* バージョン */

  for( i=0; indi_ver[i].ver; i++ ){
    mes = (const Uchar *)(indi_ver[i].ver);
    buf_ptr = &bitmap_buffer[ (320*(indi_ver[i].y) + (indi_ver[i].x)) / 8 ];
    indicate_puts( buf_ptr, 320/8, 0, mes );
  }


	/* 案内 */

  mes = (const Uchar *)indi_guide[ menu_lang ];
  buf_ptr = &bitmap_buffer[ (320*(4+48+8) + 8) / 8 ];
  indicate_puts( buf_ptr, 320/8, menu_lang, mes );


	/* 表示する。ANKのメッセージは、ID==1 */

  indicate_bitmap( -1, -1, 320, 80, bitmap_buffer, 1 );
}


/************************************************************************/


/*----------------------------------------------------------------------*/
/* BASICモードと ディスクドライブの状態を indicator_flag にセット	*/
/*----------------------------------------------------------------------*/
static	void	check_fdd_status( void )
{
  int	i;
  int	status = 0x80;

  switch( boot_basic ){
  case BASIC_N:		status |= 0x00;		break;
  case BASIC_V1S:	status |= 0x10;		break;
  case BASIC_V1H:	status |= 0x20;		break;
  case BASIC_V2:	status |= 0x30;		break;
  }

  for( i=0; i<2; i++ ){
    if( get_drive_ready( i ) ){
      if( !disk_image_exist(i)||drive_check_empty(i) ) status |= 0x0 << (i*2);
      else					       status |= 0x1 << (i*2);
    }else{
      if( !disk_image_exist(i)||drive_check_empty(i) ) status |= 0x2 << (i*2);
      else					       status |= 0x3 << (i*2);
    }
  }
  indicator_flag = ( indicator_flag & ~INDICATE_FDD_STAT ) | (status<<8);
}



/*----------------------------------------------------------------------*/
/* 画面の隅に、現在の BASICモード と、ディスクドライブの状態を表示	*/
/*----------------------------------------------------------------------*/
static Uchar bitmap24x8_V1S[]={
  0x31, 0x8c, 0x78, 
  0x31, 0x9c, 0xcc, 
  0x31, 0xac, 0xc0, 
  0x1b, 0x0c, 0x78, 
  0x1b, 0x0c, 0x0c, 
  0x0e, 0x0c, 0xcc, 
  0x0e, 0x3e, 0x78, 
  0x00, 0x00, 0x00, 
};
static Uchar bitmap24x8_V1H[]={
  0x31, 0x8c, 0xcc, 
  0x31, 0x9c, 0xcc, 
  0x31, 0xac, 0xcc, 
  0x1b, 0x0c, 0xfc, 
  0x1b, 0x0c, 0xcc, 
  0x0e, 0x0c, 0xcc, 
  0x0e, 0x3e, 0xcc, 
  0x00, 0x00, 0x00, 
};
static Uchar bitmap24x8_V2[]={
  0x06, 0x33, 0xc0, 
  0x06, 0x36, 0x60, 
  0x06, 0x30, 0x60, 
  0x03, 0x60, 0xc0, 
  0x03, 0x63, 0x80, 
  0x01, 0xc6, 0x00, 
  0x01, 0xc7, 0xe0, 
  0x00, 0x00, 0x00, 
};
static Uchar bitmap24x8_N[]={
  0x00, 0x63, 0x00, 
  0x00, 0x63, 0x00, 
  0x00, 0x73, 0x00, 
  0x00, 0x6b, 0x00, 
  0x00, 0x67, 0x00, 
  0x00, 0x63, 0x00, 
  0x00, 0x63, 0x00, 
  0x00, 0x00, 0x00, 
};
static Uchar bitmap24x8_OFF_EMPTY[]={
  0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 
  0x00, 0x1e, 0x00, 
  0x00, 0x00, 0x00, 
  0x3f, 0xff, 0xfc, 
  0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 
};
static Uchar bitmap24x8_ON_EMPTY[]={
  0x00, 0x00, 0x00, 
  0x18, 0x00, 0x00, 
  0x3c, 0x00, 0x00, 
  0x18, 0x1e, 0x00, 
  0x00, 0x00, 0x00, 
  0x3f, 0xff, 0xfc, 
  0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 
};
static Uchar bitmap24x8_OFF_EXIST[]={
  0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 
  0x00, 0x06, 0x00, 
  0x00, 0x0c, 0x00, 
  0x3f, 0xff, 0xfc, 
  0x00, 0x0c, 0x00, 
  0x00, 0x00, 0x00, 
};
static Uchar bitmap24x8_ON_EXIST[]={
  0x00, 0x00, 0x00, 
  0x18, 0x00, 0x00, 
  0x3c, 0x00, 0x00, 
  0x18, 0x06, 0x00, 
  0x00, 0x0c, 0x00, 
  0x3f, 0xff, 0xfc, 
  0x00, 0x0c, 0x00, 
  0x00, 0x00, 0x00, 
};

/*
  BASE                size( 80, 24 )
  FDD2  pos(  0,  0 ) size( 32, 13 )
  FDD1  pos( 32,  0 ) size( 32, 13 )
  MODE  pos( 48, 15 ) size( 16,  2 )
  CLK   pos( 16, 20 ) size(  8,  1 )
*/
static Uchar bitmap80x24_BASE[]={
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xbf, 0xff, 
  0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xbf, 0xff, 
  0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xbf, 0xff, 
  0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xbf, 0xff, 
  0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xbf, 0xff, 
  0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x01, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0x80, 0x00, 0x40, 0x20, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 
  0x8f, 0x80, 0x5f, 0xa0, 0x00, 0x02, 0x00, 0x00, 0x07, 0xe1, 
  0x88, 0x80, 0x50, 0xa0, 0x00, 0x02, 0x0a, 0xa0, 0x04, 0x21, 
  0x8f, 0x80, 0x5f, 0xa0, 0x00, 0x02, 0x00, 0x00, 0x07, 0xe1, 
  0x80, 0x00, 0x40, 0x20, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
};
static Uchar bitmap80x24_OFF_EMPTY[]={
  0xff, 0xff, 0xff, 0xff,
  0x80, 0x00, 0x00, 0x00,
  0x80, 0x00, 0x00, 0x00,
  0x83, 0x00, 0x30, 0x00,
  0x84, 0x80, 0x2f, 0xc0,
  0x83, 0x00, 0x20, 0x40,
  0x80, 0x00, 0x1f, 0x80,
  0x80, 0x00, 0x00, 0x04,
  0x8f, 0xff, 0xff, 0xfc,
  0x80, 0x00, 0x00, 0x00,
  0x80, 0x00, 0x00, 0x00,
  0x80, 0x00, 0x00, 0x00,
  0x80, 0x00, 0x00, 0x00,
};
static Uchar bitmap80x24_ON_EMPTY[]={
  0xff, 0xff, 0xff, 0xff,
  0x80, 0x00, 0x00, 0x00,
  0x80, 0x00, 0x00, 0x00,
  0x87, 0x80, 0x30, 0x00,
  0x87, 0x80, 0x2f, 0xc0,
  0x87, 0x80, 0x20, 0x40,
  0x80, 0x00, 0x1f, 0x80,
  0x80, 0x00, 0x00, 0x04,
  0x8f, 0xff, 0xff, 0xfc,
  0x80, 0x00, 0x00, 0x00,
  0x80, 0x00, 0x00, 0x00,
  0x80, 0x00, 0x00, 0x00,
  0x80, 0x00, 0x00, 0x00,
};
static Uchar bitmap80x24_OFF_EXIST[]={
  0xff, 0xff, 0xff, 0xff,
  0x80, 0x00, 0x00, 0x00,
  0x80, 0x00, 0x00, 0x00,
  0x83, 0x00, 0x30, 0x00,
  0x84, 0x80, 0x28, 0x00,
  0x83, 0x00, 0x24, 0x00,
  0x80, 0x00, 0x28, 0x00,
  0x8f, 0xff, 0xef, 0xfc,
  0x8f, 0xff, 0xef, 0xfc,
  0x80, 0x00, 0x28, 0x00,
  0x80, 0x00, 0x1c, 0x00,
  0x80, 0x00, 0x00, 0x00,
  0x80, 0x00, 0x00, 0x00,
};
static Uchar bitmap80x24_ON_EXIST[]={
  0xff, 0xff, 0xff, 0xff,
  0x80, 0x00, 0x00, 0x00,
  0x80, 0x00, 0x00, 0x00,
  0x87, 0x80, 0x30, 0x00,
  0x87, 0x80, 0x28, 0x00,
  0x87, 0x80, 0x24, 0x00,
  0x80, 0x00, 0x28, 0x00,
  0x8f, 0xff, 0xef, 0xfc,
  0x8f, 0xff, 0xef, 0xfc,
  0x80, 0x00, 0x28, 0x00,
  0x80, 0x00, 0x1c, 0x00,
  0x80, 0x00, 0x00, 0x00,
  0x80, 0x00, 0x00, 0x00,
};
static Uchar bitmap80x24_N[]={
  0x41, 0x04,
  0xa2, 0x8a,
};
static Uchar bitmap80x24_V1S[]={
  0xe1, 0x04,
  0xe2, 0x8a,
};
static Uchar bitmap80x24_V1H[]={
  0x43, 0x84,
  0xa3, 0x8a,
};
static Uchar bitmap80x24_V2[]={
  0x41, 0x0e,
  0xa2, 0x8e,
};
static Uchar bitmap80x24_4MHZ[]={
  0x5c,
};
static Uchar bitmap80x24_8MHZ[]={
  0x53,
};



static	void	disp_fdd_status( void )
{
  int	status = ( indicator_flag & INDICATE_FDD_STAT ) >> 8;
  Uchar *dst = bitmap_buffer;
  Uchar *src;
  int	i, x, y;

  switch( indicator_flag & INDICATE_FDD_MASK ){
  case 0x1:    x = 0;		y = 0;		break;
  case 0x3:    x = WIDTH;	y = 0;		break;
  case 0x5:    x = 0;		y = HEIGHT;	break;
  case 0x7:    x = WIDTH;	y = HEIGHT;	break;
  default:     return;
  }


  if( screen_size == SCREEN_SIZE_HALF ){

    switch( status & 0x30 ){
    case 0x00:	src = bitmap24x8_N;	break;
    case 0x10:	src = bitmap24x8_V1S;	break;
    case 0x20:	src = bitmap24x8_V1H;	break;
    default:	src = bitmap24x8_V2;	break;
    }
    bitmap_copy( dst, 24*3, src, 24, 8 );
    dst += 24/8;

//    for( i=1; i>=0; i-- ){
//      switch( ( status >> (i*2) ) & 0x03 ){
//      case 0x00:	src = bitmap24x8_OFF_EMPTY;	break;
//      case 0x01:	src = bitmap24x8_OFF_EXIST;	break;
//      case 0x02:	src = bitmap24x8_ON_EMPTY;	break;
//      default:		src = bitmap24x8_ON_EXIST;	break;
//      }
//      bitmap_copy( dst, 24*3, src, 24, 8 );
//      dst += 24/8;
//    }
	//この辺でアクセスランプいけるかも
    i = 1;
      switch( ( status >> (i*2) ) & 0x03 ){
		case 0x00: pgPrint_drawbg(0,7,0xFFFF,0     ,"Drive2"); break;
		case 0x01: pgPrint_drawbg(0,7,0xFFFF,0     ,"Drive2"); break;
		case 0x02: pgPrint_drawbg(0,7,0xFFFF,0xfc00,"Drive2"); break;
		default:   pgPrint_drawbg(0,7,0xFFFF,0xfc00,"Drive2"); break;
	}
    i = 0;
      switch( ( status >> (i*2) ) & 0x03 ){
		case 0x00: pgPrint_drawbg(0,6,0xFFFF,0     ,"Drive1"); break;
		case 0x01: pgPrint_drawbg(0,6,0xFFFF,0     ,"Drive1"); break;
		case 0x02: pgPrint_drawbg(0,6,0xFFFF,0xfc00,"Drive1"); break;
		default:   pgPrint_drawbg(0,6,0xFFFF,0xfc00,"Drive1"); break;
	}

    indicate_bitmap( x, y, 24*3, 8, bitmap_buffer, 0 );

  }else{

    bitmap_copy( dst, 80, bitmap80x24_BASE, 80, 24 );

    for( i=1; i>=0; i-- ){
      switch( ( status >> (i*2) ) & 0x03 ){
      case 0x00:	src = bitmap80x24_OFF_EMPTY;	break;
      case 0x01:	src = bitmap80x24_OFF_EXIST;	break;
      case 0x02:	src = bitmap80x24_ON_EMPTY;	break;
      default:		src = bitmap80x24_ON_EXIST;	break;
      }
      if( i==1 ) bitmap_copy( dst + 0/8 +0*80/8,  80, src, 32, 13 );
      else       bitmap_copy( dst +32/8 +0*80/8,  80, src, 32, 13 );
    }

    switch( status & 0x30 ){
    case 0x00:	src = bitmap80x24_N;	break;
    case 0x10:	src = bitmap80x24_V1S;	break;
    case 0x20:	src = bitmap80x24_V1H;	break;
    default:	src = bitmap80x24_V2;	break;
    }
    bitmap_copy( dst +48/8 +15*80/8,  80, src, 16, 2 );

    switch( status & 0x40 ){
    case 0x00:	src = bitmap80x24_4MHZ;	break;
    default:	src = bitmap80x24_8MHZ;	break;
    }
    bitmap_copy( dst +16/8 +20*80/8,  80, src, 8, 1 );

    indicate_bitmap( x, y, 80, 24, bitmap_buffer, 0 );

  }

}



/*----------------------------------------------------------------------*/
/* 画面の中央に、メッセージを一定時間表示				*/
/*									*/
/*	indicator_flag の ビットに意味をもたせてある			*/
/*		INDICATE_MES_TIME	表示時間			*/
/*		INDICATE_MES_ALLWAYS	真なら、常時表示		*/
/*		INDICATE_MES_ID		メッセージの種類		*/
/*----------------------------------------------------------------------*/

static	void	disp_message( void )
{
  char	str[32];
  int	drv;
  char	*name;
  int	rw;

  switch( (indicator_flag & INDICATE_MES_ID) >> INDICATE_MED_ID_SHIFT ){

  case INDICATE_MES_ID_FRATE:
    sprintf( str, " FRAME  %2d/sec ", 60/frameskip_rate );
    break;

  case INDICATE_MES_ID_VOL:
#ifdef USE_SOUND
    sprintf( str, " VOLUME  %3d[db] ", xmame_get_sound_volume() );
#else
    sprintf( str, "                 " );
#endif
    break;

  case INDICATE_MES_ID_PAUSE:
    sprintf( str, " PAUSE (ESC:cancel) " );
    break;

  case INDICATE_MES_ID_WAIT_ON:
    sprintf( str, " WAIT  ON  " );
    break;

  case INDICATE_MES_ID_WAIT_OFF:
    sprintf( str, " WAIT  OFF " );
    break;

  case INDICATE_MES_ID_WAIT:
    sprintf( str, " WAIT  %6.2f[Hz] ", wait_freq_hz );
    break;

  case INDICATE_MES_ID_DR1_EMP:
    sprintf( str, " DRIVE 1: %-17s %c ", "<<<<< Eject >>>>>", ' ' );
    break;
  case INDICATE_MES_ID_DR2_EMP:
    sprintf( str, " DRIVE 2: %-17s %c ", "<<<<< Eject >>>>>", ' ' );
    break;

  case INDICATE_MES_ID_DR1_CHG:
    drv = 0;
    name = drive[drv].image[ disk_image_now_selected(drv) ].name;
    rw  = (drive[drv].image[ disk_image_now_selected(drv) ].protect) ?'P' :' ';
    sprintf( str, " DRIVE %d: %-17s %c ", drv+1, name, rw );
    break;

  case INDICATE_MES_ID_DR2_CHG:
    drv = 1;
    name = drive[drv].image[ disk_image_now_selected(drv) ].name;
    rw  = (drive[drv].image[ disk_image_now_selected(drv) ].protect) ?'P' :' ';
    sprintf( str, " DRIVE %d: %-17s %c ", drv+1, name, rw );
    break;

  case INDICATE_MES_ID_LOGO:
    indicate_logo();
    return;

  case INDICATE_MES_ID_SUSPEND:
    sprintf( str, " ** SUSPEND ... Done ** " );
    break;

  default:	/* BUG ? */
    indicator_flag &= ~INDICATE_MES;
    return;
  }

  indicate_font( str );
}





/************************************************************************/
/* FDD の表示状態変更							*/
/************************************************************************/
void	indicate_change_fdd_stat( void )
{
  indicator_flag = (++indicator_flag) & 
			    ( INDICATE_FDD_MASK | INDICATE_MES_MASK );

  reset_frame_counter();
  do_update = TRUE;
}




/************************************************************************/
/* フレームスキップ数変更 : -frameskip の値を、変更する。		*/
/*		変更した後は、しばらく画面にフレームレートを表示させる	*/
/************************************************************************/
void	indicate_change_frame( int sign )
{
  int	i;
  int	wait;

  static const char next[] = { 1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60, };
  static const char prev[] = { 60, 30, 20, 15, 12, 10, 6, 5, 4, 3, 2, 1, };

  if( sign < 0 ){

    for( i=0; i<countof(next)-1; i++ )
      if( frameskip_rate <= next[i] ){ frameskip_rate = next[i+1];  break; }
    if( i==countof(next)-1 ) frameskip_rate = next[0];	/* ループさせよう */

  }else{

    for( i=0; i<countof(prev)-1; i++ )
      if( frameskip_rate >= prev[i] ){ frameskip_rate = prev[i+1]; break; }
    if( i==countof(prev)-1 ) frameskip_rate = prev[0];	/* ループさせよう */

  }

  blink_ctrl_update();

  wait = 60/frameskip_rate +1 +1;			/* 1 sec */
  indicator_flag = ( indicator_flag & ~INDICATE_MES_MASK )
			| INDICATE_MES
			| ( INDICATE_MES_ID_FRATE << INDICATE_MED_ID_SHIFT )
			| ( wait  << INDICATE_MES_TIME_SHIFT ) ;

  reset_frame_counter();

  change_indicator = TRUE;
}


/************************************************************************/
/* ボリューム変更 : -vol の値を、変更する。				*/
/*		変更した後は、しばらく画面に音量を表示させる		*/
/************************************************************************/
void	indicate_change_volume( int sign )
{
#ifdef USE_SOUND
  int	wait;
  if( use_sound ){
    int diff = (sign>0) ? +1 : ( (sign<0)?-1:0);
    if (diff){
      int vol = xmame_get_sound_volume() + diff;
      if( vol >   0 ) vol = 0;
      if( vol < -32 ) vol = -32;
      xmame_set_sound_volume( vol );
    }

    wait = 60/frameskip_rate +1 +1;			/* 1 sec */
    indicator_flag = ( indicator_flag & ~INDICATE_MES_MASK )
			| INDICATE_MES
			| ( INDICATE_MES_ID_VOL << INDICATE_MED_ID_SHIFT )
			| ( wait  << INDICATE_MES_TIME_SHIFT ) ;

    reset_frame_counter();

    change_indicator = TRUE;
  }
#endif
}


/************************************************************************/
/* ウエイト用周期: -nowait、-wait_freq の値を、変更する。		*/
/*		変更した後は、しばらく画面にウエイト用周期を表示させる	*/
/************************************************************************/
void	indicate_change_wait( int sign )
{
  int	mes_id;
  int	wait;

  wait = 60/frameskip_rate +1 +1;			/* 1 sec */
  /* ウエイトが変わるので、表示時間もぜんぜん一致しないぞ………  */

  if( sign==0 ){

    no_wait ^= 1;
    if( no_wait ) mes_id = INDICATE_MES_ID_WAIT_OFF;
    else          mes_id = INDICATE_MES_ID_WAIT_ON;

  }else if( sign < 0 ){

    wait_freq_hz -= 5.0;
    if( wait_freq_hz < 10.0 ) wait_freq_hz = 10.0;
    mes_id = INDICATE_MES_ID_WAIT;

  }else{

    wait_freq_hz += 5.0;
    if( wait_freq_hz > 240.0 ) wait_freq_hz = 240.0;
    mes_id = INDICATE_MES_ID_WAIT;

  }

  indicator_flag = ( indicator_flag & ~INDICATE_MES_MASK )
			| INDICATE_MES
			| ( mes_id << INDICATE_MED_ID_SHIFT )
			| ( wait  << INDICATE_MES_TIME_SHIFT ) ;
  
  reset_frame_counter();

  change_indicator = TRUE;
}


/************************************************************************/
/* ドライブを一時的に空の状態にする					*/
/*		画面にメッセージを常時表示しておく。			*/
/************************************************************************/
void	indicate_change_image_empty( int drv )
{
  int	mes_id;

  if( disk_image_exist( drv ) ){

    drive_set_empty( drv );
    
    if( drv==0 ) mes_id = INDICATE_MES_ID_DR1_EMP;
    else         mes_id = INDICATE_MES_ID_DR2_EMP;

    indicator_flag = ( indicator_flag & ~INDICATE_MES_MASK )
			| INDICATE_MES
			| ( mes_id << INDICATE_MED_ID_SHIFT )
			| INDICATE_MES_ALLWAYS;
    reset_frame_counter();

    change_indicator = TRUE;
  }
}
/************************************************************************/
/* ドライブのイメージを次(前)のイメージに変更する。			*/
/*		変更した後は、しばらく画面にイメージ名を表示させる	*/
/************************************************************************/
void	indicate_change_image_change( int drv, int direction )
{
  int	img;
  int	mes_id;
  int	wait;

  if( disk_image_exist( drv ) ){

    img = disk_image_now_selected(drv);
    img += direction;
    if( img < 0 ) img = disk_image_num_of_drive(drv)-1;
    if( img >= disk_image_num_of_drive(drv) ) img = 0;

    drive_unset_empty( drv );
    disk_change_image( drv, img );


    if( drv==0 ) mes_id = INDICATE_MES_ID_DR1_CHG;
    else         mes_id = INDICATE_MES_ID_DR2_CHG;

    wait = 150/frameskip_rate +1 +1;			/* 2.5 sec */
    indicator_flag = ( indicator_flag & ~INDICATE_MES_MASK )
			| INDICATE_MES
			| ( mes_id << INDICATE_MED_ID_SHIFT )
			| ( wait  << INDICATE_MES_TIME_SHIFT ) ;
    reset_frame_counter();

    change_indicator = TRUE;
  }
}

/************************************************************************/
/* 画面中央に PAUSE を表示するための設定				*/
/*		実際の PAUSE はOS依存なので、pause.c にある。		*/
/************************************************************************/
void	indicate_change_pause( void )
{

  indicator_flag = ( indicator_flag & ~INDICATE_MES_MASK )
			| INDICATE_MES
			| ( INDICATE_MES_ID_PAUSE << INDICATE_MED_ID_SHIFT )
			| INDICATE_MES_ALLWAYS;

  reset_frame_counter();

  change_indicator = TRUE;
}




/************************************************************************/
/* 画面中央に タイトルロゴ を表示する。					*/
/*		起動時にのみ、この関数を呼びだそう。			*/
/************************************************************************/
void	indicate_bootup_logo( void )
{
  int	wait = 3*60/frameskip_rate +1 +1;			/* 3 sec */

  if( bootup_logo ){
    indicator_flag = ( indicator_flag & ~INDICATE_MES_MASK )
			| INDICATE_MES
			| ( INDICATE_MES_ID_LOGO << INDICATE_MED_ID_SHIFT )
			| ( wait  << INDICATE_MES_TIME_SHIFT ) ;

    reset_frame_counter();

    change_indicator = TRUE;
  }
}


/************************************************************************/
/* 画面中央に SUSPEND を表示するための設定				*/
/************************************************************************/
void	indicate_change_suspend( void )
{
  int	wait = 1.5*60/frameskip_rate +1 +1;			/* 1.5 sec */

  indicator_flag = ( indicator_flag & ~INDICATE_MES_MASK )
			| INDICATE_MES
			| ( INDICATE_MES_ID_SUSPEND << INDICATE_MED_ID_SHIFT )
			| ( wait  << INDICATE_MES_TIME_SHIFT ) ;

  change_indicator = TRUE;
}




/************************************************************************/
/* メッセージなどを表示する						*/
/*	screen_buf 更新後に呼ぶ						*/
/************************************************************************/


void	disp_indicator( void )
{
  static Uint old;

    /* FDDステータス表示時は、状況(アクセスランプなど)の変化をチェック */

  if( indicator_flag & INDICATE_FDD ) check_fdd_status();


    /* メッセージ表示の場合、表示残り時間をデクリメント */

  if( indicator_flag & INDICATE_MES ){
    if( (indicator_flag & INDICATE_MES_ALLWAYS) == 0 ){
      indicator_flag -= (1 << INDICATE_MES_TIME_SHIFT);
      if( (indicator_flag & INDICATE_MES_TIME) == 0 ){
	indicator_flag &= ~INDICATE_MES;
      }
    }
  }

  if( do_update ){		/* 表示する場合 (VRAM/TVRAM更新時) は、	*/
				/* インジケータをつねに上書き表示	*/

    if( indicator_flag & INDICATE_FDD ) disp_fdd_status();
    if( indicator_flag & INDICATE_MES ) disp_message();

  }else{			/* 表示しない場合は、インジケータの	*/
				/* 表示の必要がある場合のみ、上書き表示	*/

    if( indicator_flag & INDICATE_FDD  &&
	( old ^ indicator_flag ) & INDICATE_FDD_STAT ){
      disp_fdd_status();
      do_update = TRUE;
    }
    if( change_indicator ){
      disp_message();
      do_update = TRUE;
    }
  }

  old = indicator_flag;
  change_indicator = FALSE;
}
